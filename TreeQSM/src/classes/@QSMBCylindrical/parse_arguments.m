% Helper function to parse input arguments for various methods. Arguments
% are mostly given in name-value pairs, but some flag arguments can be
% also given without a value pair. In this case the default value is used.
% The Param structure array is modified and returned. Args cell array holds
% the input arguments to be processed. Accepted is a cell array of argument
% name strings that are accepted for the calling method.



% This file is part of QSM-Blocks.
% 
% QSM-Blocks is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% QSM-Blocks is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with QSM-Blocks.  If not, see <http://www.gnu.org/licenses/>.

function Param = parse_arguments(ob, Param, Args, Accepted)

    % Index of current optional argument.
    iArgin = 1;

    % Process optional arguments.
    while iArgin <= size(Args,2)

        % Arguments can be single string values or string-other
        % pairs. Check that current argument is a string.
        if ischar(Args{iArgin})

            if not(any(ismember(Accepted, lower(Args{iArgin}))))
                disp([...
                    'Ignoring unknown parameter: ' ...
                    Args{iArgin}...
                ]);
            end

            switch lower(Args{iArgin})

                % Flag: create compressed model.
                case 'compressed'

                    % Argument given without pair, set flag to
                    % TRUE.
                    if iArgin == numel(Args) || ...
                        ischar(Args{iArgin+1})

                        Param.FCompressed = true;

                    % Argument given with legal pair.
                    % Pair should be logical.
                    elseif islogical(Args{iArgin+1})

                        % Set closed flag.
                        Param.FCompressed = Args{iArgin+1};
                        
                        % Skip argument pair.
                        iArgin = iArgin + 1;

                    % Illegal pair value.
                    else
                        error([...
                            'Illegal variable type following ''' ...
                            Args{iArgin} ...
                            '''' ...
                        ]);
                    end

                % Assing header cell array.
                case 'header'

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );

                    % Argument pair should be a cell array or a 
                    % string.
                    assert(...
                        iscell(Args{iArgin+1}) || ...
                        ischar(Args{iArgin+1}), ...
                        ['Header argument should be a string or ' ...
                        'a cell array of strings.'] ...
                    );

                    % Set header.
                    Header = Args{iArgin+1};

                    % Ensure that variable is a cell array.
                    if ischar(Header)
                        Header = {Header};
                    end

                    Param.Header = Header;

                    % Skip argument pair.
                    iArgin = iArgin + 1;

                % Float precision.
                case 'precision'

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );

                    % Argument pair should be an integer or an
                    % integer vector.
                    assert(...
                        isnumeric(Args{iArgin+1}) && ...
                        all(mod(Args{iArgin+1},1) == 0), ...
                        'Float precision should be an integer.' ...
                    );

                    % Set precision.
                    Param.FloatPrec = Args{iArgin+1};

                    % Skip argument pair.
                    iArgin = iArgin + 1;

                % Cylinder face count.
                case 'facecount'

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );

                    % Argument pair should be an integer or an
                    % integer vector.
                    assert(...
                        isnumeric(Args{iArgin+1}) && ...
                        all(mod(Args{iArgin+1},1) == 0), ...
                        'Face count should be an integer.' ...
                    );

                    % Set face count.
                    Param.FaceCount = Args{iArgin+1};

                    % Skip argument pair.
                    iArgin = iArgin + 1;

                % Flag: closed cylinders.
                case 'closed'

                    % Argument given without pair, set flag to
                    % TRUE.
                    if iArgin == numel(Args) || ...
                        ischar(Args{iArgin+1})

                        Param.FClosed = true;

                    % Argument given with legal pair.
                    % Pair should be logical.
                    elseif islogical(Args{iArgin+1})

                        % Set closed flag.
                        Param.FClosed = Args{iArgin+1};
                        
                        % Skip argument pair.
                        iArgin = iArgin + 1;

                    % Illegal pair value.
                    else
                        error([...
                            'Illegal variable type following ''' ...
                            Args{iArgin} ...
                            '''' ...
                        ]);
                    end

                % Flag: use quads instead of triangles.
                case 'quads'

                    % Argument given without pair, set flag to
                    % TRUE.
                    if iArgin == numel(Args) || ...
                        ischar(Args{iArgin+1})

                        Param.FQuads = true;

                    % Argument given with legal pair.
                    % Pair should be logical.    
                    elseif islogical(Args{iArgin+1})

                        % Set quads flag.
                        Param.FQuads = Args{iArgin+1};

                        % Skip argument pair.
                        iArgin = iArgin + 1;

                    % Illegal pair value.
                    else
                        error([...
                            'Illegal variable type following ''' ...
                            Args{iArgin} ...
                            '''' ...
                        ]);
                    end

                % Flag: use trianglulated stem vertices and faces
                % and exclude respective cylinders.
                case 'trianglestem'

                    % Argument given without pair, set flag to
                    % TRUE.
                    if iArgin == numel(Args) || ...
                        ischar(Args{iArgin+1})

                        Param.FTriStem = true;

                    % Argument given with legal pair.
                    % Pair should be logical.    
                    elseif islogical(Args{iArgin+1})

                        % Set trianglestem flag.
                        Param.FTriStem = Args{iArgin+1};

                        % Skip argument pair.
                        iArgin = iArgin + 1;

                    % Illegal pair value.
                    else
                        error([...
                            'Illegal variable type following ''' ...
                            Args{iArgin} ...
                            '''' ...
                        ]);
                    end

                    if Param.FTriStem && not(ob.has_triangle_stem)
                        Param.FTriStem = false;
                        warning([ ...
                            'Model does not have triangulated stem, ' ...
                            'but TriangleStem attribute set to true.' ...
                        ]);
                    end

                % Flag: include comments.
                case 'comments'

                    % Argument given without pair, set flag to
                    % TRUE.
                    if iArgin == numel(Args) || ...
                        ischar(Args{iArgin+1})

                        Param.FComment = true;

                    % Argument given with legal pair.
                    % Pair should be logical.    
                    elseif islogical(Args{iArgin+1})

                        % Set quads flag.
                        Param.FComment = Args{iArgin+1};

                        % Skip argument pair.
                        iArgin = iArgin + 1;

                    % Illegal pair value.
                    else
                        error([...
                            'Illegal variable type following ''' ...
                            Args{iArgin} ...
                            '''' ...
                        ]);
                    end

                % Flag: scale color values.
                case 'scalecolor'

                    % Argument given without pair, set flag to
                    % TRUE.
                    if iArgin == numel(Args) || ...
                        ischar(Args{iArgin+1})

                        Param.FScaleColor = true;

                    % Argument given with legal pair.
                    % Pair should be logical.
                    elseif islogical(Args{iArgin+1})

                        % Set flag.
                        Param.FScaleColor = Args{iArgin+1};

                        % Skip argument pair.
                        iArgin = iArgin + 1;

                    % Illegal pair value.
                    else
                        error([...
                            'Illegal variable type following ''' ...
                            Args{iArgin} ...
                            '''' ...
                        ]);
                    end
                    
                % Cylinder selection filter vector.
                case 'filter'

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );
                    
                    % Paired value is logical.
                    if islogical(Args{iArgin+1})

                        % Set filter vector.
                        Param.ICyl = Args{iArgin+1};

                    % Paired value is sting.
                    elseif ischar(Args{iArgin+1})

                        % Try to get set from method.
                        % Throws error is unkown.
                        Param.ICyl = ob.get_cylinder_set(Args{iArgin+1});

                    % Illegal pair value.
                    else
                        error([ ...
                            'Illegal variable type following ''' ...
                            Args{iArgin} ...
                            '''. Should be logical or string.' ...
                        ]);
                    end
                    
                    % Activate filtering flag.
                    Param.FFilter = true;
                    
                    % Skip argument pair.
                    iArgin = iArgin + 1;

                % Cylinder color vector or matrix.
                case {'color', 'colour'}

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );

                    % Paired argument should be a [N x 1] vector or
                    % [N x 3] matrix, where N is the block count.
                    assert(...
                        isnumeric(Args{iArgin+1}) && ...
                        ( ...
                            ((size(Args{iArgin+1},2) == 1 || ...
                            size(Args{iArgin+1},2) == 3) && ...
                            size(Args{iArgin+1},1) == ...
                                ob.block_count) || ...
                            (size(Args{iArgin+1},2) == 3 && ...
                            size(Args{iArgin+1},1) == 1) ...
                        ), ...
                        [ ...
                            'Color parameter must be a column vector ' ...
                            'or 3-element wide matrix with the ' ...
                            'vertical dimension matching object ' ...
                            'block count.' ...
                        ] ...
                    );
                
                    % Set color data.
                    CylColor = Args{iArgin+1};

                    % A vector is copied to create RGB matrix.
                    if size(CylColor,2) == 1
                        CylColor = repmat(CylColor,1,3);
                    end

                    if size(CylColor,1) == 1
                        CylColor = repmat(CylColor,ob.block_count,1);
                    end

                    Param.CylColor = CylColor;

                    % Set color flag true.
                    Param.FColor = true;

                    % Skip argument pair.
                    iArgin = iArgin + 1;

                % Color mode for plotting.
                case 'colorsource'

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );

                    % Paired argument should be a string.
                    assert(...
                        ischar(Args{iArgin+1}), ...
                        'ColorMode parameter must be a string.' ...
                    );

                    Param.ColorSource = Args{iArgin+1};

                    % Skip argument pair.
                    iArgin = iArgin + 1;

                % Color matrix to be used while plotting (discrete)
                % properties.
                case 'colormatrix'

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );

                    % Paired argument should be a [N x 3] matrix.
                    assert(...
                        isnumeric(Args{iArgin+1}) && ...
                        size(Args{iArgin+1},2) == 3, ...
                        [ ...
                            'Color matrix must be a [N x 3] matrix a ' ...
                            'RGB color value on each row.' ...
                        ] ...
                    );

                    Param.ColorMatrix = Args{iArgin+1};

                    % Skip argument pair.
                    iArgin = iArgin + 1;

                % Translation offset vector.
                case 'origin'

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );

                    % Paired argument should be a three-element 
                    % vector.
                    assert(...
                        isnumeric(Args{iArgin+1}) && ...
                        length(Args{iArgin+1}) == 3, ...
                        ['Origin parameter should be a three-element ' ...
                        'numeric vector.'] ...
                    );

                    % Ensure row vector.
                    Param.Origin = transpose(Args{iArgin+1}(:));

                    % Skip argument pair.
                    iArgin = iArgin + 1;

                % Extra numeric data to print.
                case 'extradata'

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );

                    % Can also be empty, for legacy support.
                    if isempty(Args{iArgin+1})
                        % Do nothing.
                    else

                        if iscell(Args{iArgin+1})
                            assert(...
                                numel(Args{iArgin+1}) <= 3, ...
                                ['Extra data should have less than 4 ' ...
                                'elements when given in cell format.'] ...
                            );
                            assert(...
                                isempty(Args{iArgin+1}{1}) || ...
                                (isnumeric(Args{iArgin+1}{1}) && ...
                                size(Args{iArgin+1}{1},1) == ...
                                    ob.block_count), ...
                                ['Extra data cell array first element ' ...
                                'should be empty or numeric and have ' ...
                                'vertical dimension matching ' ...
                                'cylinder count.'] ...
                            );

                            if numel(Args{iArgin+1}) > 1
                                assert(...
                                    isempty(Args{iArgin+1}{2}) || ...
                                    (isnumeric(Args{iArgin+1}{2}) && ...
                                    size(Args{iArgin+1}{2},1) == ...
                                        ob.branch_count), ...
                                    ['Extra data cell array second ' ...
                                    'element should be empty or ' ...
                                    'numeric and have vertical ' ...
                                    'dimension matching branch count.'] ...
                                );
                            end

                            if numel(Args{iArgin+1}) > 2
                                assert(...
                                    isempty(Args{iArgin+1}{3}) || ...
                                    isnumeric(Args{iArgin+1}{3}) || ...
                                    iscell(Args{iArgin+1}{3}), ...
                                    ['Extra data cell array third ' ...
                                    'element should be empty or ' ...
                                    'numeric or a cell array.'] ...
                                );
                            end
                        else
                            % Paired argument should be numeric and 
                            % row count should match block count.
                            assert(...
                                isnumeric(Args{iArgin+1}) && ...
                                size(Args{iArgin+1},1) == ...
                                    ob.block_count, ...
                                ['Extra data should be empty or ' ...
                                'numeric and have vertical dimension ' ...
                                'matching cylinder count.'] ...
                            );
                        end

                        % Set extra data.
                        Param.ExtraData = Args{iArgin+1};

                        % Update flag.
                        Param.FExtraData = true;

                    end

                    % Skip argument pair.
                    iArgin = iArgin + 1;

                % Parameters that are passed to plotting commands.
                case 'plotoptions'

                    % Paired argument required.
                    assert(...
                        iArgin+1 <= numel(Args), ...
                        [ ...
                            'Argument ''' ...
                            Args{iArgin} ...
                            ''' missing paired value.' ...
                        ] ...
                    );

                    % Argument pair should be a cell array or a 
                    % string.
                    assert(...
                        iscell(Args{iArgin+1}), ...
                        'PlotOptions argument should be a cell array.' ...
                    );

                    Param.PlotOptions = Args{iArgin+1};

                % Unknown arguments.
                otherwise
                    disp([...
                        'Ignoring unknown parameter: ' ...
                        Args{iArgin}...
                    ]);
            end
        end

        % Move to next argument.
        iArgin = iArgin + 1;
    end
end